{"ast":null,"code":"'use strict'; // tar -r\n\nconst hlo = require('./high-level-opt.js');\n\nconst Pack = require('./pack.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst t = require('./list.js');\n\nconst path = require('path'); // starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\n\nconst Header = require('./header.js');\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n\n  if (!opt.file) {\n    throw new TypeError('file is required');\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives');\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified');\n  }\n\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+');\n      } else {\n        throw er;\n      }\n    }\n\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives');\n        }\n\n        if (!bytes) {\n          break POSITION;\n        }\n      }\n\n      const h = new Header(headBuf);\n\n      if (!h.cksumValid) {\n        break;\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n\n      if (position + entryBlockSize + 512 > st.size) {\n        break;\n      } // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n\n\n      position += entryBlockSize;\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n    }\n\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er));\n      } else {\n        cb_(null, pos);\n      }\n    };\n\n    let position = 0;\n\n    if (size === 0) {\n      return cb(null, 0);\n    }\n\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er);\n      }\n\n      bufPos += bytes;\n\n      if (bufPos < 512 && bytes) {\n        return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'));\n      } // truncated header\n\n\n      if (bufPos < 512) {\n        return cb(null, position);\n      }\n\n      const h = new Header(headBuf);\n\n      if (!h.cksumValid) {\n        return cb(null, position);\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position);\n      }\n\n      position += entryBlockSize + 512;\n\n      if (position >= size) {\n        return cb(null, position);\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n\n      if (er) {\n        return reject(er);\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er));\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er);\n          }\n\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      });\n    } else {\n      p.add(file);\n    }\n  });\n  p.end();\n};\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files));\n    } else {\n      p.add(file);\n    }\n  }\n\n  p.end();\n};","map":{"version":3,"names":["hlo","require","Pack","fs","fsm","t","path","Header","module","exports","opt_","files","cb","opt","file","TypeError","gzip","brotli","endsWith","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","Buffer","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","slice","noResume","onentry","entry","add","end","shift"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}