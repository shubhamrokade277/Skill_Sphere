{"ast":null,"code":"'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert');\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst mkdir = require('./mkdir.js');\n\nconst wc = require('./winchars.js');\n\nconst pathReservations = require('./path-reservations.js');\n\nconst stripAbsolutePath = require('./strip-absolute-path.js');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nconst normalize = require('./normalize-unicode.js');\n\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\n\nconst crypto = require('crypto');\n\nconst getFlag = require('./get-write-flag.js');\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024; // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb);\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er);\n    }\n\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path);\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nconst uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c; // clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\n\n\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path))).toLowerCase();\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs);\n\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path);\n\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path);\n    }\n  }\n};\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key);\n  }\n};\n\nclass Unpack extends Parser {\n  constructor(opt) {\n    if (!opt) {\n      opt = {};\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true;\n      this[MAYBECLOSE]();\n    };\n\n    super(opt);\n    this[CHECKED_CWD] = false;\n    this.reservations = pathReservations();\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    this.writable = true;\n    this.readable = false;\n    this[PENDING] = 0;\n    this[ENDED] = false;\n    this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid');\n      }\n\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n\n      this.uid = opt.uid;\n      this.gid = opt.gid;\n      this.setOwner = true;\n    } else {\n      this.uid = null;\n      this.gid = null;\n      this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0;\n    } else {\n      this.preserveOwner = !!opt.preserveOwner;\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null; // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n\n    this.maxDepth = typeof opt.maxDepth === 'number' ? opt.maxDepth : DEFAULT_MAX_DEPTH; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    this.win32 = !!opt.win32 || isWindows; // do not unpack over files that are newer than what's in the archive\n\n    this.newer = !!opt.newer; // do not unpack over ANY files\n\n    this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    this.unlink = !!opt.unlink;\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    this.strip = +opt.strip || 0; // if we're not chmodding, then we don't need the process umask\n\n    this.processUmask = opt.noChmod ? 0 : process.umask();\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask; // default mode for dirs created as parents\n\n    this.dmode = opt.dmode || 0o0777 & ~this.umask;\n    this.fmode = opt.fmode || 0o0666 & ~this.umask;\n    this.on('entry', entry => this[ONENTRY](entry));\n  } // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n\n\n  warn(code, msg) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false;\n    }\n\n    return super.warn(code, msg, data);\n  }\n\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n    }\n  }\n\n  [CHECKPATH](entry) {\n    const p = normPath(entry.path);\n    const parts = p.split('/');\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false;\n      }\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/');\n\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/');\n        } else {\n          return false;\n        }\n      }\n\n      parts.splice(0, this.strip);\n      entry.path = parts.join('/');\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth\n      });\n      return false;\n    }\n\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p\n        });\n        return false;\n      } // strip off the root\n\n\n      const [root, stripped] = stripAbsolutePath(p);\n\n      if (root) {\n        entry.path = stripped;\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p\n        });\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path));\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path));\n    } // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n\n    /* istanbul ignore if - defense in depth */\n\n\n    if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd\n      });\n      return false;\n    } // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n\n\n    if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') {\n      return false;\n    } // only encode : chars that aren't drive letter indicators\n\n\n    if (this.win32) {\n      const {\n        root: aRoot\n      } = path.win32.parse(entry.absolute);\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));\n      const {\n        root: pRoot\n      } = path.win32.parse(entry.path);\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n    }\n\n    return true;\n  }\n\n  [ONENTRY](entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume();\n    }\n\n    assert.equal(typeof entry.absolute, 'string');\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700;\n        }\n\n      // eslint-disable-next-line no-fallthrough\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry);\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry);\n    }\n  }\n\n  [ONERROR](er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er);\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, {\n        entry\n      });\n      this[UNPEND]();\n      entry.resume();\n    }\n  }\n\n  [MKDIR](dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod\n    }, cb);\n  }\n\n  [DOCHOWN](entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n  }\n\n  [UID](entry) {\n    return uint32(this.uid, entry.uid, this.processUid);\n  }\n\n  [GID](entry) {\n    return uint32(this.gid, entry.gid, this.processGid);\n  }\n\n  [FILE](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false\n    });\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {});\n      } // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n\n\n      stream.write = () => true;\n\n      this[ONERROR](er, entry);\n      fullyDone();\n    });\n    let actions = 1;\n\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {});\n        }\n\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry);\n          } else {\n            this[UNPEND]();\n          }\n\n          fullyDone();\n        });\n      }\n    };\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute;\n      const fd = stream.fd;\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        fs.futimes(fd, atime, mtime, er => er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er)) : done());\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        fs.fchown(fd, uid, gid, er => er ? fs.chown(abs, uid, gid, er2 => done(er2 && er)) : done());\n      }\n\n      done();\n    });\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry);\n        fullyDone();\n      });\n      entry.pipe(tx);\n    }\n\n    tx.pipe(stream);\n  }\n\n  [DIRECTORY](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n\n      let actions = 1;\n\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone();\n          this[UNPEND]();\n          entry.resume();\n        }\n      };\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);\n      }\n\n      done();\n    });\n  }\n\n  [UNSUPPORTED](entry) {\n    entry.unsupported = true;\n    this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, {\n      entry\n    });\n    entry.resume();\n  }\n\n  [SYMLINK](entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done);\n  }\n\n  [HARDLINK](entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n    this[LINK](entry, linkpath, 'link', done);\n  }\n\n  [PEND]() {\n    this[PENDING]++;\n  }\n\n  [UNPEND]() {\n    this[PENDING]--;\n    this[MAYBECLOSE]();\n  }\n\n  [SKIP](entry) {\n    this[UNPEND]();\n    entry.resume();\n  } // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n\n\n  [ISREUSABLE](entry, st) {\n    return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n  } // check if a thing is there, and if so, try to clobber it\n\n\n  [CHECKFS](entry) {\n    this[PEND]();\n    const paths = [entry.path];\n\n    if (entry.linkpath) {\n      paths.push(entry.linkpath);\n    }\n\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n  }\n\n  [PRUNECACHE](entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache);\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute);\n    }\n  }\n\n  [CHECKFS2](entry, fullyDone) {\n    this[PRUNECACHE](entry);\n\n    const done = er => {\n      this[PRUNECACHE](entry);\n      fullyDone(er);\n    };\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry);\n          done();\n          return;\n        }\n\n        this[CHECKED_CWD] = true;\n        start();\n      });\n    };\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute));\n\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry);\n              done();\n              return;\n            }\n\n            afterMakeParent();\n          });\n        }\n      }\n\n      afterMakeParent();\n    };\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry);\n          done();\n          return;\n        }\n\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done);\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n\n            const afterChmod = er => this[MAKEFS](er, entry, done);\n\n            if (!needChmod) {\n              return afterChmod();\n            }\n\n            return fs.chmod(entry.absolute, entry.mode, afterChmod);\n          } // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n\n\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done));\n          }\n        } // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n\n\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done);\n        }\n\n        unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done));\n      });\n    };\n\n    if (this[CHECKED_CWD]) {\n      start();\n    } else {\n      checkCwd();\n    }\n  }\n\n  [MAKEFS](er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done);\n\n      case 'Link':\n        return this[HARDLINK](entry, done);\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done);\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done);\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry);\n      } else {\n        this[UNPEND]();\n        entry.resume();\n      }\n\n      done();\n    });\n  }\n\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\n\nclass UnpackSync extends Unpack {\n  [MAKEFS](er, entry) {\n    return super[MAKEFS](er, entry, () => {});\n  }\n\n  [CHECKFS](entry) {\n    this[PRUNECACHE](entry);\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode);\n\n      if (er) {\n        return this[ONERROR](er, entry);\n      }\n\n      this[CHECKED_CWD] = true;\n    } // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n\n\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute));\n\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode);\n\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry);\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));\n\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry);\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry);\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode);\n        }) : [];\n        return this[MAKEFS](er, entry);\n      } // not a dir entry, have to remove it\n\n\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute));\n      this[MAKEFS](er, entry);\n    } // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n\n\n    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));\n    this[MAKEFS](er, entry);\n  }\n\n  [FILE](entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n\n    const oner = er => {\n      let closeError;\n\n      try {\n        fs.closeSync(fd);\n      } catch (e) {\n        closeError = e;\n      }\n\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry);\n      }\n\n      done();\n    };\n\n    let fd;\n\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n    } catch (er) {\n      return oner(er);\n    }\n\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length);\n      } catch (er) {\n        oner(er);\n      }\n    });\n    tx.on('end', _ => {\n      let er = null; // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n\n        try {\n          fs.futimesSync(fd, atime, mtime);\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime);\n          } catch (utimeser) {\n            er = futimeser;\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n\n        try {\n          fs.fchownSync(fd, uid, gid);\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid);\n          } catch (chowner) {\n            er = er || fchowner;\n          }\n        }\n      }\n\n      oner(er);\n    });\n  }\n\n  [DIRECTORY](entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    const er = this[MKDIR](entry.absolute, mode);\n\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n      } catch (er) {}\n    }\n\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n      } catch (er) {}\n    }\n\n    done();\n    entry.resume();\n  }\n\n  [MKDIR](dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      });\n    } catch (er) {\n      return er;\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute);\n      done();\n      entry.resume();\n    } catch (er) {\n      return this[ONERROR](er, entry);\n    }\n  }\n\n}\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"names":["assert","require","Parser","fs","fsm","path","mkdir","wc","pathReservations","stripAbsolutePath","normPath","stripSlash","normalize","ONENTRY","Symbol","CHECKFS","CHECKFS2","PRUNECACHE","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","crypto","getFlag","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","DEFAULT_MAX_DEPTH","unlinkFile","cb","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","cacheKeyNormalize","toLowerCase","pruneCache","cache","abs","keys","pnorm","indexOf","delete","dropCache","key","Unpack","constructor","opt","ondone","_","reservations","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","maxDepth","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","noChmod","umask","dmode","fmode","on","entry","warn","code","msg","data","recoverable","emit","p","parts","split","length","type","linkparts","linkpath","slice","join","splice","isFinite","depth","includes","test","root","stripped","isAbsolute","absolute","resolvedPath","aRoot","parse","encode","pRoot","resume","equal","mode","dir","preserve","fullyDone","stream","WriteStream","flags","size","autoClose","fd","close","write","actions","done","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","unsupported","st","isFile","nlink","paths","push","reserve","checkCwd","start","parent","dirname","afterMakeParent","lstat","lstatEr","isDirectory","needChmod","afterChmod","chmod","rmdir","link","callSync","fn","UnpackSync","mkParent","lstatSync","chmodSync","rmdirSync","oner","closeError","closeSync","e","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","sync","Sync","module","exports"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/tar/lib/unpack.js"],"sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\nconst DEFAULT_MAX_DEPTH = 1024\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth = typeof opt.maxDepth === 'number'\n      ? opt.maxDepth\n      : DEFAULT_MAX_DEPTH\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    const p = normPath(entry.path)\n    const parts = p.split('/')\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n      parts.splice(0, this.strip)\n      entry.path = parts.join('/')\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth,\n      })\n      return false\n    }\n\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}