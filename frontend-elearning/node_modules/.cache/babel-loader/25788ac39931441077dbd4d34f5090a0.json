{"ast":null,"code":"'use strict'; // tar -u\n\nconst hlo = require('./high-level-opt.js');\n\nconst r = require('./replace.js'); // just call tar.r with the filter and mtimeCache\n\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n\n  if (!opt.file) {\n    throw new TypeError('file is required');\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives');\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified');\n  }\n\n  files = Array.from(files);\n  mtimeFilter(opt);\n  return r(opt, files, cb);\n};\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter;\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map();\n  }\n\n  opt.filter = filter ? (path, stat) => filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime) : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime);\n};","map":{"version":3,"names":["hlo","require","r","module","exports","opt_","files","cb","opt","file","TypeError","gzip","brotli","endsWith","Array","isArray","length","from","mtimeFilter","filter","mtimeCache","Map","path","stat","get","mtime"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/tar/lib/update.js"],"sourcesContent":["'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n"],"mappings":"AAAA,a,CAEA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,qBAAD,CAAnB;;AACA,MAAMC,CAAC,GAAGD,OAAO,CAAC,cAAD,CAAjB,C,CACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,CAACC,IAAD,EAAOC,KAAP,EAAcC,EAAd,KAAqB;EACpC,MAAMC,GAAG,GAAGR,GAAG,CAACK,IAAD,CAAf;;EAEA,IAAI,CAACG,GAAG,CAACC,IAAT,EAAe;IACb,MAAM,IAAIC,SAAJ,CAAc,kBAAd,CAAN;EACD;;EAED,IAAIF,GAAG,CAACG,IAAJ,IAAYH,GAAG,CAACI,MAAhB,IAA0BJ,GAAG,CAACC,IAAJ,CAASI,QAAT,CAAkB,KAAlB,CAA1B,IAAsDL,GAAG,CAACC,IAAJ,CAASI,QAAT,CAAkB,MAAlB,CAA1D,EAAqF;IACnF,MAAM,IAAIH,SAAJ,CAAc,sCAAd,CAAN;EACD;;EAED,IAAI,CAACJ,KAAD,IAAU,CAACQ,KAAK,CAACC,OAAN,CAAcT,KAAd,CAAX,IAAmC,CAACA,KAAK,CAACU,MAA9C,EAAsD;IACpD,MAAM,IAAIN,SAAJ,CAAc,mCAAd,CAAN;EACD;;EAEDJ,KAAK,GAAGQ,KAAK,CAACG,IAAN,CAAWX,KAAX,CAAR;EAEAY,WAAW,CAACV,GAAD,CAAX;EACA,OAAON,CAAC,CAACM,GAAD,EAAMF,KAAN,EAAaC,EAAb,CAAR;AACD,CAnBD;;AAqBA,MAAMW,WAAW,GAAGV,GAAG,IAAI;EACzB,MAAMW,MAAM,GAAGX,GAAG,CAACW,MAAnB;;EAEA,IAAI,CAACX,GAAG,CAACY,UAAT,EAAqB;IACnBZ,GAAG,CAACY,UAAJ,GAAiB,IAAIC,GAAJ,EAAjB;EACD;;EAEDb,GAAG,CAACW,MAAJ,GAAaA,MAAM,GAAG,CAACG,IAAD,EAAOC,IAAP,KACpBJ,MAAM,CAACG,IAAD,EAAOC,IAAP,CAAN,IAAsB,EAAEf,GAAG,CAACY,UAAJ,CAAeI,GAAf,CAAmBF,IAAnB,IAA2BC,IAAI,CAACE,KAAlC,CADL,GAEf,CAACH,IAAD,EAAOC,IAAP,KAAgB,EAAEf,GAAG,CAACY,UAAJ,CAAeI,GAAf,CAAmBF,IAAnB,IAA2BC,IAAI,CAACE,KAAlC,CAFpB;AAGD,CAVD"},"metadata":{},"sourceType":"script"}