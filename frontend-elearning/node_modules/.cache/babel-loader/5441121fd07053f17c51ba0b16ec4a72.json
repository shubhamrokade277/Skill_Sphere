{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\n\nconst EE = require('events');\n\nconst Stream = require('stream');\n\nconst stringdecoder = require('string_decoder');\n\nconst SD = stringdecoder.StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode'); // internal event when stream is destroyed\n\nconst DESTROYED = Symbol('destroyed'); // internal event when stream has an error\n\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\n\nconst defer = fn => Promise.resolve().then(fn); // TODO remove when Node v8 support drops\n\n\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n\n    this.ondrain = () => src[RESUME]();\n\n    dest.on('drain', this.ondrain);\n  }\n\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  } // istanbul ignore next - only here for the prototype\n\n\n  proxyErrors() {}\n\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n\n    this.proxyErrors = er => dest.emit('error', er);\n\n    src.on('error', this.proxyErrors);\n  }\n\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false; // whether we're explicitly paused\n\n    this[PAUSED] = false;\n    this[PIPES] = [];\n    this[BUFFER] = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n\n    this[SIGNAL] = options && options.signal;\n    this[ABORTED] = false;\n\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]());\n\n      if (this[SIGNAL].aborted) {\n        this[ABORT]();\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n\n  get ['async']() {\n    return this[ASYNC];\n  }\n\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  } // drop everything and get out of the flow completely\n\n\n  [ABORT]() {\n    this[ABORTED] = true;\n    this.emit('abort', this[SIGNAL].reason);\n    this.destroy(this[SIGNAL].reason);\n  }\n\n  get aborted() {\n    return this[ABORTED];\n  }\n\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false;\n    if (this[EOF]) throw new Error('write after end');\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f(); // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    } // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n\n\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n\n\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n\n    if (typeof chunk === 'string' && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk); // Note: flushing CAN potentially switch us into not-flowing mode\n\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null;\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n\n    if (this[OBJECTMODE]) n = null;\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this[BUFFER][0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false; // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n\n  get destroyed() {\n    return this[DESTROYED];\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  get paused() {\n    return this[PAUSED];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    return this[BUFFER].shift();\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk);\n    return this.flowing;\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors; // piping an ended stream ends immediately\n\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n\n    return dest;\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    } // Some other unknown event\n\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n\n        super.emit('data', data);\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  } // const all = await stream.collect()\n\n\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n    // by triggering the flow here.\n\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  } // const data = await stream.concat()\n\n\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  } // stream.promise().then(() => done, er => emitted error)\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      stopped = true;\n      return Promise.resolve({\n        done: true\n      });\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        resolve({\n          done: true\n        });\n      };\n\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ASYNCITERATOR]() {\n        return this;\n      }\n\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      this.removeListener(ERROR, stop);\n      this.removeListener(DESTROYED, stop);\n      this.removeListener('end', stop);\n      stopped = true;\n      return {\n        done: true\n      };\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        value\n      };\n    };\n\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(DESTROYED, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ITERATOR]() {\n        return this;\n      }\n\n    };\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n\n    this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er); // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && ( // readable\n    typeof s.pipe === 'function' || // writable\n    typeof s.write === 'function' && typeof s.end === 'function'));\n  }\n\n}\n\nexports.Minipass = Minipass;","map":{"version":3,"names":["proc","process","stdout","stderr","EE","require","Stream","stringdecoder","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","Minipass","options","objectMode","encoding","async","writable","readable","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","signal","addEventListener","aborted","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","reason","destroy","_","cb","assign","code","f","from","buffer","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","ended","p","find","splice","indexOf","addListener","removeAllListeners","call","emittedEnd","data","listeners","extra","collect","buf","dataLength","promise","c","reject","stopped","stop","done","next","res","value","onerr","ondata","onend","ondestroy","rej","throw","return","close","isStream","s","exports"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}