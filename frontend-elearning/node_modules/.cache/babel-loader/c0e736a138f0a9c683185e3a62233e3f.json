{"ast":null,"code":"'use strict'; // A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor(path, absolute) {\n    this.path = path || './';\n    this.absolute = absolute;\n    this.entry = null;\n    this.stat = null;\n    this.readdir = null;\n    this.pending = false;\n    this.ignore = false;\n    this.piped = false;\n  }\n\n}\n\nconst {\n  Minipass\n} = require('minipass');\n\nconst zlib = require('minizlib');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst WriteEntry = require('./write-entry.js');\n\nconst WriteEntrySync = WriteEntry.Sync;\nconst WriteEntryTar = WriteEntry.Tar;\n\nconst Yallist = require('yallist');\n\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst warner = require('./warn-mixin.js');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor(opt) {\n    super(opt);\n    opt = opt || Object.create(null);\n    this.opt = opt;\n    this.file = opt.file || '';\n    this.cwd = opt.cwd || process.cwd();\n    this.maxReadSize = opt.maxReadSize;\n    this.preservePaths = !!opt.preservePaths;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.prefix = normPath(opt.prefix || '');\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.readdirCache = opt.readdirCache || new Map();\n    this[WRITEENTRYCLASS] = WriteEntry;\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n\n    this.portable = !!opt.portable;\n    this.zip = null;\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive');\n      }\n\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {};\n        }\n\n        if (this.portable) {\n          opt.gzip.portable = true;\n        }\n\n        this.zip = new zlib.Gzip(opt.gzip);\n      }\n\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {};\n        }\n\n        this.zip = new zlib.BrotliCompress(opt.brotli);\n      }\n\n      this.zip.on('data', chunk => super.write(chunk));\n      this.zip.on('end', _ => super.end());\n      this.zip.on('drain', _ => this[ONDRAIN]());\n      this.on('resume', _ => this.zip.resume());\n    } else {\n      this.on('drain', this[ONDRAIN]);\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse;\n    this.follow = !!opt.follow;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true;\n    this[QUEUE] = new Yallist();\n    this[JOBS] = 0;\n    this.jobs = +opt.jobs || 4;\n    this[PROCESSING] = false;\n    this[ENDED] = false;\n  }\n\n  [WRITE](chunk) {\n    return super.write(chunk);\n  }\n\n  add(path) {\n    this.write(path);\n    return this;\n  }\n\n  end(path) {\n    if (path) {\n      this.write(path);\n    }\n\n    this[ENDED] = true;\n    this[PROCESS]();\n    return this;\n  }\n\n  write(path) {\n    if (this[ENDED]) {\n      throw new Error('write after end');\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path);\n    } else {\n      this[ADDFSENTRY](path);\n    }\n\n    return this.flowing;\n  }\n\n  [ADDTARENTRY](p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path)); // in this case, we don't have to wait for the stat\n\n    if (!this.filter(p.path, p)) {\n      p.resume();\n    } else {\n      const job = new PackJob(p.path, absolute, false);\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n      job.entry.on('end', _ => this[JOBDONE](job));\n      this[JOBS] += 1;\n      this[QUEUE].push(job);\n    }\n\n    this[PROCESS]();\n  }\n\n  [ADDFSENTRY](p) {\n    const absolute = normPath(path.resolve(this.cwd, p));\n    this[QUEUE].push(new PackJob(p, absolute));\n    this[PROCESS]();\n  }\n\n  [STAT](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    const stat = this.follow ? 'stat' : 'lstat';\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n\n      if (er) {\n        this.emit('error', er);\n      } else {\n        this[ONSTAT](job, stat);\n      }\n    });\n  }\n\n  [ONSTAT](job, stat) {\n    this.statCache.set(job.absolute, stat);\n    job.stat = stat; // now we have the stat, we can filter it.\n\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true;\n    }\n\n    this[PROCESS]();\n  }\n\n  [READDIR](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n\n      if (er) {\n        return this.emit('error', er);\n      }\n\n      this[ONREADDIR](job, entries);\n    });\n  }\n\n  [ONREADDIR](job, entries) {\n    this.readdirCache.set(job.absolute, entries);\n    job.readdir = entries;\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    if (this[PROCESSING]) {\n      return;\n    }\n\n    this[PROCESSING] = true;\n\n    for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n      this[PROCESSJOB](w.value);\n\n      if (w.value.ignore) {\n        const p = w.next;\n        this[QUEUE].removeNode(w);\n        w.next = p;\n      }\n    }\n\n    this[PROCESSING] = false;\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF);\n      } else {\n        super.write(EOF);\n        super.end();\n      }\n    }\n  }\n\n  get [CURRENT]() {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n  }\n\n  [JOBDONE](job) {\n    this[QUEUE].shift();\n    this[JOBS] -= 1;\n    this[PROCESS]();\n  }\n\n  [PROCESSJOB](job) {\n    if (job.pending) {\n      return;\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job);\n      }\n\n      return;\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute));\n      } else {\n        this[STAT](job);\n      }\n    }\n\n    if (!job.stat) {\n      return;\n    } // filtered out!\n\n\n    if (job.ignore) {\n      return;\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute));\n      } else {\n        this[READDIR](job);\n      }\n\n      if (!job.readdir) {\n        return;\n      }\n    } // we know it doesn't have an entry, because that got checked above\n\n\n    job.entry = this[ENTRY](job);\n\n    if (!job.entry) {\n      job.ignore = true;\n      return;\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job);\n    }\n  }\n\n  [ENTRYOPT](job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix\n    };\n  }\n\n  [ENTRY](job) {\n    this[JOBS] += 1;\n\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', () => this[JOBDONE](job)).on('error', er => this.emit('error', er));\n    } catch (er) {\n      this.emit('error', er);\n    }\n  }\n\n  [ONDRAIN]() {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume();\n    }\n  } // like .pipe() but using super, because our write() is special\n\n\n  [PIPE](job) {\n    job.piped = true;\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n\n    const source = job.entry;\n    const zip = this.zip;\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause();\n        }\n      });\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause();\n        }\n      });\n    }\n  }\n\n  pause() {\n    if (this.zip) {\n      this.zip.pause();\n    }\n\n    return super.pause();\n  }\n\n});\n\nclass PackSync extends Pack {\n  constructor(opt) {\n    super(opt);\n    this[WRITEENTRYCLASS] = WriteEntrySync;\n  } // pause/resume are no-ops in sync streams.\n\n\n  pause() {}\n\n  resume() {}\n\n  [STAT](job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync';\n    this[ONSTAT](job, fs[stat](job.absolute));\n  }\n\n  [READDIR](job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute));\n  } // gotta get it all in this tick\n\n\n  [PIPE](job) {\n    const source = job.entry;\n    const zip = this.zip;\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk);\n      });\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk);\n      });\n    }\n  }\n\n}\n\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"names":["PackJob","constructor","path","absolute","entry","stat","readdir","pending","ignore","piped","Minipass","require","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","normPath","Pack","opt","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","brotli","TypeError","Gzip","BrotliCompress","chunk","write","_","end","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","add","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","shift","has","get","isDirectory","code","msg","data","warn","forEach","base","replace","source","pause","PackSync","readdirSync","module","exports"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive')\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}