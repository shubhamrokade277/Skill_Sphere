{"ast":null,"code":"'use strict'; // this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js');\n\nconst Header = require('./header.js');\n\nconst EE = require('events');\n\nconst Yallist = require('yallist');\n\nconst maxMetaEntrySize = 1024 * 1024;\n\nconst Entry = require('./read-entry.js');\n\nconst Pax = require('./pax.js');\n\nconst zlib = require('minizlib');\n\nconst {\n  nextTick\n} = require('process');\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\nconst CLOSESTREAM = Symbol('closeStream');\n\nconst noop = _ => true;\n\nmodule.exports = warner(class Parser extends EE {\n  constructor(opt) {\n    opt = opt || {};\n    super(opt);\n    this.file = opt.file || ''; // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n\n    this[SAW_VALID_ENTRY] = null; // these BADARCHIVE errors can't be detected early. listen on DONE.\n\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n      }\n    });\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone);\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n      });\n    }\n\n    this.strict = !!opt.strict;\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop; // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n\n    const isTBR = opt.file && (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')); // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli : isTBR ? undefined : false; // have to set this so that streams are ok piping into it\n\n    this.writable = true;\n    this.readable = false;\n    this[QUEUE] = new Yallist();\n    this[BUFFER] = null;\n    this[READENTRY] = null;\n    this[WRITEENTRY] = null;\n    this[STATE] = 'begin';\n    this[META] = '';\n    this[EX] = null;\n    this[GEX] = null;\n    this[ENDED] = false;\n    this[UNZIP] = null;\n    this[ABORTED] = false;\n    this[SAW_NULL_BLOCK] = false;\n    this[SAW_EOF] = false;\n    this.on('end', () => this[CLOSESTREAM]());\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry);\n    }\n  }\n\n  [CONSUMEHEADER](chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false;\n    }\n\n    let header;\n\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX]);\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er);\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true; // ending an archive with no entries.  pointless, but legal.\n\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header';\n        }\n\n        this[EMIT]('eof');\n      } else {\n        this[SAW_NULL_BLOCK] = true;\n        this[EMIT]('nullBlock');\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false;\n\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {\n          header\n        });\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {\n          header\n        });\n      } else {\n        const type = header.type;\n\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n            header\n          });\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n            header\n          });\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]); // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true;\n                }\n              };\n\n              entry.on('end', onend);\n            } else {\n              this[SAW_VALID_ENTRY] = true;\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true;\n              this[EMIT]('ignoredEntry', entry);\n              this[STATE] = 'ignore';\n              entry.resume();\n            } else if (entry.size > 0) {\n              this[META] = '';\n              entry.on('data', c => this[META] += c);\n              this[STATE] = 'meta';\n            }\n          } else {\n            this[EX] = null;\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry);\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry);\n              this[STATE] = entry.remain ? 'ignore' : 'header';\n              entry.resume();\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body';\n              } else {\n                this[STATE] = 'header';\n                entry.end();\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry);\n                this[NEXTENTRY]();\n              } else {\n                this[QUEUE].push(entry);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM]() {\n    nextTick(() => this.emit('close'));\n  }\n\n  [PROCESSENTRY](entry) {\n    let go = true;\n\n    if (!entry) {\n      this[READENTRY] = null;\n      go = false;\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry);\n    } else {\n      this[READENTRY] = entry;\n      this.emit('entry', entry);\n\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]());\n        go = false;\n      }\n    }\n\n    return go;\n  }\n\n  [NEXTENTRY]() {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()));\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY];\n      const drainNow = !re || re.flowing || re.size === re.remain;\n\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain');\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'));\n      }\n    }\n  }\n\n  [CONSUMEBODY](chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY];\n    const br = entry.blockRemain;\n    const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);\n    entry.write(c);\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header';\n      this[WRITEENTRY] = null;\n      entry.end();\n    }\n\n    return c.length;\n  }\n\n  [CONSUMEMETA](chunk, position) {\n    const entry = this[WRITEENTRY];\n    const ret = this[CONSUMEBODY](chunk, position); // if we finished, then the entry is reset\n\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry);\n    }\n\n    return ret;\n  }\n\n  [EMIT](ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra);\n    } else {\n      this[QUEUE].push([ev, data, extra]);\n    }\n  }\n\n  [EMITMETA](entry) {\n    this[EMIT]('meta', this[META]);\n\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false);\n        break;\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true);\n        break;\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].path = this[META].replace(/\\0.*/, '');\n        break;\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].linkpath = this[META].replace(/\\0.*/, '');\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error('unknown meta: ' + entry.type);\n    }\n  }\n\n  abort(error) {\n    this[ABORTED] = true;\n    this.emit('abort', error); // always throws, even in non-strict mode\n\n    this.warn('TAR_ABORT', error, {\n      recoverable: false\n    });\n  }\n\n  write(chunk) {\n    if (this[ABORTED]) {\n      return;\n    } // first write, might be gzipped\n\n\n    const needSniff = this[UNZIP] === null || this.brotli === undefined && this[UNZIP] === false;\n\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk]);\n        this[BUFFER] = null;\n      }\n\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk;\n        return true;\n      } // look for gzip header\n\n\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false;\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined;\n\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true;\n          } else {\n            this[BUFFER] = chunk;\n            return true;\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512));\n            this.brotli = false;\n          } catch (_) {\n            this.brotli = true;\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {\n        const ended = this[ENDED];\n        this[ENDED] = false;\n        this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress();\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n        this[UNZIP].on('error', er => this.abort(er));\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true;\n          this[CONSUMECHUNK]();\n        });\n        this[WRITING] = true;\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk);\n        this[WRITING] = false;\n        return ret;\n      }\n    }\n\n    this[WRITING] = true;\n\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk);\n    } else {\n      this[CONSUMECHUNK](chunk);\n    }\n\n    this[WRITING] = false; // return false if there's a queue, or if the current entry isn't flowing\n\n    const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true; // if we have no queue, then that means a clogged READENTRY\n\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'));\n    }\n\n    return ret;\n  }\n\n  [BUFFERCONCAT](c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n    }\n  }\n\n  [MAYBEEND]() {\n    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {\n      this[EMITTEDEND] = true;\n      const entry = this[WRITEENTRY];\n\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0;\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {\n          entry\n        });\n\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER]);\n        }\n\n        entry.end();\n      }\n\n      this[EMIT](DONE);\n    }\n  }\n\n  [CONSUMECHUNK](chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk);\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]();\n    } else {\n      this[CONSUMING] = true;\n\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk);\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      } else {\n        this[CONSUMECHUNKSUB](chunk);\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      }\n\n      this[CONSUMING] = false;\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]();\n    }\n  }\n\n  [CONSUMECHUNKSUB](chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0;\n    const length = chunk.length;\n\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position);\n          position += 512;\n          break;\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position);\n          break;\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error('invalid state: ' + this[STATE]);\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);\n      } else {\n        this[BUFFER] = chunk.slice(position);\n      }\n    }\n  }\n\n  end(chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk);\n      } else {\n        this[ENDED] = true;\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0);\n        this.write(chunk);\n      }\n    }\n  }\n\n});","map":{"version":3,"names":["warner","require","Header","EE","Yallist","maxMetaEntrySize","Entry","Pax","zlib","nextTick","gzipHeader","Buffer","from","STATE","Symbol","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","SAW_VALID_ENTRY","SAW_NULL_BLOCK","SAW_EOF","CLOSESTREAM","noop","_","module","exports","Parser","constructor","opt","file","on","warn","ondone","emit","strict","filter","isTBR","endsWith","brotli","gzip","undefined","writable","readable","onwarn","onentry","chunk","position","header","er","nullBlock","cksumValid","path","type","test","linkpath","entry","remain","onend","invalid","meta","size","ignore","resume","c","end","push","go","Array","isArray","apply","emittedEnd","shift","length","re","drainNow","flowing","once","br","blockRemain","slice","write","ret","ev","data","extra","parse","Object","create","replace","Error","abort","error","recoverable","needSniff","concat","i","maybeBrotli","ended","Unzip","BrotliDecompress","have","alloc"],"sources":["D:/CDAC PROJECT/Skill_Sphere/frontend-elearning/node_modules/tar/lib/parse.js"],"sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst { nextTick } = require('process')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR = (opt.file && (\n        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    const needSniff = this[UNZIP] === null ||\n      this.brotli === undefined && this[UNZIP] === false\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n\n      // look for gzip header\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = this[UNZIP] === null\n          ? new zlib.Unzip()\n          : new zlib.BrotliDecompress()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)\n        this.write(chunk)\n      }\n    }\n  }\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}